# 操作系统lab4实验报告 #
# 14061106 朱化磊 #
## 一、Thinking ##
### Thinking 4.1 ###
（1）

        子进程完全按照fork()之后父进程的代码执行，说明子进程从父进程那里拷贝了大多数的信息和状态，从后面的实验里可以看出，子进程
    和父进程在大多数的用户空间里都是共享额一份信息。

（2）

        子进程没有执行fork()之前的代码，说明父进程在创建子进程的时候，将对子进程的pc做了手脚，将其设为执行完fork之后的第一步。

### Thinking 4.2
    
        我认为选C。
        在fork里会通过syscall陷入内核，转而执行sys_env_alloc，父进程会通过这个函数创建一个新的进程，将其的env_tf中的PC值存为
    sys_env_alloc结束后的第一条指令的地址，2号寄存器存为0，但是sys_env_alloc执行完时会将返回值存到2号寄存器，执行完后的第一条
    指令便是将2号寄存器的值赋给函数调用时用的变量，所以父进程执行时所得到的envid是其自身的id，等到子进程跑起来的时候，由于会切换
    进程上下文，此时2号寄存器的值被替换为之前所存在env_tf中的2号寄存器的值0，所以第一条指令便是把0赋给函数调用时的变量。我们看起
    来fork有两个返回值并不是因为执行了两次，而是因为完整的fork其实是由两部分组成，然而在这两部分之间穿插了进程上下文的切换动作，
    导致最后的返回值是不同的。

### Thinking 4.3
        用户进程在运行时所使用的实际空间是UTOP之下，在这个空间中，我觉得需要保护的区域是UTEXT到USTACKTOP，而不能保护的是
    UXSTACKTOP - BY2PG到UXSTACKTOP的空间，其余的0到UTEXT和USTACKTOP之上的BY2PG的空间是没有必要保护的。
        UXSTACKTOP - BY2PG到UXSTACKTOP的空间是用户进程的异常栈，在写时保护的机制下，若发生写操作，会触发页异常，若这段空间仍
    旧被保护，就会导致死循环，而进程没有用到0到UTEXT的空间，USTACKTOP之上的BY2PG的空间在空间分布图上是Invalid memory，所以我
    觉得不用保护。

### Thinking 4.4
（1）
        vpt和vpd分别是得到一个虚拟地址所在的页面的物理地址和二级页表的物理地址。
        用法如下：
        若某一个虚拟地址为address，则其所在的页面的物理地址为(*vpt)[VPN(address)]，所在的二级页表的物理地址为(*vpd)[PDX(address)]。
        
（2）
        出现的背景是在fork中，我们只关心某个虚拟地址所对应的物理页面地址和二级页表地址，而不是得到其对应的物理地址，所以为了符合
    二级页表的查询机制，通过vpt和vpd去构造一个新的虚拟地址。
        其原理大致如下：
        我们在lab3中创建进程时有如下语句
```C
        e->env_pgdir[PDX(VPT)]   = e->env_cr3;
        e->env_pgdir[PDX(UVPT)]  = e->env_cr3 | PTE_V | PTE_R;
```
        对于一个虚拟地址address，其所对应的物理页面地址其实只需要知道其前20位就够了，那么为了访问到所对应的物理页面地址，我们
    构造了虚拟地址PDX(VPT)|PDX(address)|PTX(address)|00，
        根据二级页表的访问机制可知第一步通过PDX(VPT)得到的还是自身，再经过PDX(address)可以得到所对应的二级页表，最后通过
    PTX(address)可以得到物理页面地址。
        根据以上，若要得到address所在的二级页表的物理地址的话，只需要在如上的虚拟地址稍作改动即可，
        PDX(VPT)|PDX(VPT)|PDX(address)|00，
        前两步都得到自身，最后的PDX(address)可得到二级页表的物理地址。
        如果要在lab2中实现这样的功能，可以仿照lab3中的代码，在pmap.c的mips_vm_init中加上如下代码：
```C
        pgdir[PDX(mCONTEXT)] = mCONTEXT;
```

## 二、实验难点图示

        下面是这次实验的大致示意图：
        这次实验的关键点在于fork的实现
![流程图](https://raw.githubusercontent.com/HualeiZhu/BUAA_MIPS_OS_DOC/master/lab4_fork.png)


        关于进程间通讯机制，我用文字叙述一下，函数sys_ipc_recv的作用是将当前进程设置为待接收的状态，并放弃时间片等待其他进程
    给自己发信息，函数sys_ipc_can_send的作用是给目标进程发送信息，从函数的参数中，我本来是这样以为的，将自己的srcva所对应的
    页面先复制一份儿，以权限perm映射到目标进程的dstva所对应的页面，这样就输送了一个页面的信息，但是这样写总是出现死循环，后
    来我才发现，在测试代码中srcva一直给的是0，所以在page_lookup的时候一直失败，然后我又细看了注释和测试代码，意识到自己想多
    了，这次的进程通讯仅仅输送了一个value，但我觉得我之前的想法应该是合理的。

        下面是我觉得这次实验最让我头痛的几个地方：
    （1）sys_yeild
        在这里我不禁联想到了lab3中的TIMESTACK，我又有了新的理解，我认为产生进程间切换的原因有很多，处理方式也有很多，但是这些
    处理方式在保存进程上下文的时候都会将当前上下文保存到TIMESTACK中，然后在启动新进程的时候就有了一个契约，保存上下文只需要将
    TIMESTACK中的内容存到自身的Trapframe中即可。
        我也想过为什么不直接保存，或许是想通过TIMESTACK中转站可以使得进程有一个指定的上下文，意思就是说假设一个进程运行到指令
    A，产生了系统调用的中断，在中断处理的过程中或许要修改自身的Trapframe。（感觉说的不对）
    （2）0指的是当前进程
        在env.c中的envid2env函数中，判断如果传入的envid为0则将参数e设置为当前进程。在写duppage的时候需要考虑到这一点，进程间
    的id是相对而言的，我看我自己就是0，看别人才是别人真正的id，这也说明一个用户进程的id一定不会是0。
    （3）syscall...
        注意在用户态中，无法直接调用我们所写的以sys开头的函数，需要用syscall开头的对应的函数去实现，在这些syscall函数中都会
    调用mysyscall，然后会将我们要使用的系统函数的地址传进去并陷入内核，系统就能从第一个参数得到信息从而转到相应的函数。这点
    我之前一直没注意到，忽略了这是从用户态转入内核态了。
    （4）页的保护机制
        在duppage里我们要将合适的页面保护起来，判断是否保护的依据就是页面的权限位，我们的实验中是用写时保护机制来进行保护的，
    关键的权限位即为PTE_COW。
        若页面是共享（PTE_LIBRAY）的，说明父子进程都可以进行修改且不影响各自的运行，则不需要加上PTE_COW权限位，若不是共享，
    则需要加上PTE_COW实现写时保护。

## 三、实验感想
        这次实验的代码量挺多的，但syscall_all.c中的函数比较好填，这也占了大多数的代码，剩余的fork.c中的函数很让人头痛，需要注
    意的地方有点儿多。估计这次实验花了40个小时左右吧。
        感觉lab4中最有趣的地方是fork的两个返回值的问题，第一次看到时觉得好神奇，一个函数竟然有两个返回值，前所未见，看了一遍
    指导书之后仍旧迷迷糊糊的，然而在做实验的过程当中，某一天中午睡醒觉的时候突然就明白了，有种豁然开朗的感觉，弄懂一个地方还
    是会给自己带来一丝快乐的。
        最后还是希望下次实验自己可以做快点儿，做得更加明白一些。

## 四、指导书反馈
        这次有两个测试代码，而且这两个测试也不是针对同一个地方，进程通讯的pingpong肯定是基于第一个fktest的，但是在指导书中是
    先讲了进程通讯然后再讲了fork，而fork是这次实验中自我感觉最难的部分，所以搞定fork花费的时间过长使得再调通讯时有些陌生，所
    以我建议稍微调一下指导书的顺序，先将fork讲完，附上第一个测试样例，调通之后再讲通讯，即把两个测试样例和其对应的讲解部分分
    开。

