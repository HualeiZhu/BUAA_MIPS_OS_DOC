# 操作系统Lab2实验报告 #
# 14061106 朱化磊 #
## 一、实验思考题 ##
### Thinking 3.1 ###
    用do{...}while(0)，可以防止一些很难发现的错误，比如对于下面这个宏定义：
    不加do{...}while(0)
```C
#define print(ab)  \
{          \
    pritnf("a");  \
	printf("b");   \
}
```
    加do{...}while(0)
```C
#define print(ab)  \
	do{          \
		pritnf("a");  \
		printf("b");   \
	}while(0)
```
    我们大家应该都习惯调用一个函数后面加括号的做法，所以如果一个程序是这样的：
```C
int main()
{
    //......
    print(ab);
    //......
}
```
    展开后：
    不加do{...}while(0)
```C
int main()
{
// ...
{
    printf("a");
    printf("b");
}
//...
}
```
    加do{...}while(0)
```C
int main()
{
	// ...
	do{
		printf("a");
		printf("b");
	}while(0);
	//...
}
```
    	我们注意到，在第一个宏定义展开后，大括号后面多了一个分号，但是这个分号并
    不会影响程序的执行，而第二个宏定义展开后是一个完整的只循环一次代码段，那为什
    么还要加do{...}while(0)呢？
    	我们稍微改动一下程序：
```C
int main()
{
	// ...
	if(blablabla)
		print(ab);
	else
		print(cd);
	//...
}
```
    再看两个宏定义展开后是什么样
    不加do{...}while(0)
```C
int main()
{
	// ...
	if(blablabla)
	{
		printf("a");
		printf("b");
	};
	else
	{
		printf("a");
		printf("b");
	};
	//...
}
```    
    加do{...}while(0)
```C
int main()
{
	// ...
	if(blablabla)
	do{
		printf("a");
		printf("b");
	}while(0);
	else
	do{
		printf("c");
		printf("d");
	}while(0);
	//...
}
```
        我们可以明显看出，在第一个的宏展开里，if大括号后面的分号是无法编译过的，此时
    这个分号就不是可以忽略的因素了，但是第二个宏展开却仍然是一段没有语法错误的代码。
    通过上面这个例子，可以看出当将宏函数用于条件判断后的执行语句时要特别注意，否则可
    能产生意想不到的错误，而do{...}while(0)恰恰可以解决这类问题。
### Thinking 3.2 ###
    	设虚拟内存总共有4G，地址格式为10+10+12，页面大小为4KB，x为所有的二级页表的虚拟起
    始地址，而二级页表所占的4MB是总共内存的第x>>22个4MB，在所有的二级页表中，第一个二
    级页表对应着第1个4MB，第二个页表对应着第二个4MB，以此类推，所以第x>>22个4MB是第
    x>>22个页表所对应的，即第x>>22个页表对应着本身所有二级页表的4MB，所以其起始地址
    便为一级页表的起始地址。一个页面占用4KB的大小，那么其地址为x+(x>>22)<<12=x+x>>10，
    再本题中，即为0xC0300000。
### Thinking 3.3 ###
    	大体流程为现将CP0的CP0_ENTRYHI号寄存器数存进GPR[k1]，然后将GPR[a0]写进CP0_ENTRYHI
    号寄存器，之后查询TLB，将CP0_INDEX中的数取出来，判断是否小于0，如果小于0则跳转到NOFOUND，
    否则将CP0_ENTRYHI和CP0_ENTRYLOO置为0。
		CP0中的INDEX号寄存器中的值决定该指令要读写的是哪一个TLB表项，当缺失的时候会置其最
    高位为1，也就变成了负数。
## 实验难点图示 ##
![流程图](https://raw.githubusercontent.com/HualeiZhu/BUAA_MIPS_OS_DOC/master/Lab2.png)
 
        然后在来来回回的往复中，莽莽撞撞地好歹做完了这次实验。下面是我对这次实验的整
    个过程的理解。        
        首先在main函数中调用mips_init函数，里面主要有四个函数：
```C
mips_detect_memory(); // 主要确定内存大小，页面数目，
mips_vm_init(); // 建立起虚拟地址和物理地址的相互映射机制
page_init();  // 建立起虚拟地址与页面的映射机制
page_check();  // 测试用函数
```
    	整体的流程是，首先是通过mips_detect_memory计算内存、页面数等的值，相当于构建
    了一个整体的框架。
    	然后通过mips_vm_init建立虚实的映射，首先是用alloc函数分配了一级页表，此时虚拟
    地址为0x80400000，一页的大小为4KB，所以一级页表所占用的空间为0x80400000到
    0x80400fff，然后建立了页面结构的数组pages，一个结构占12个字节，故pages占用
    0x80401000到0x80403fff，之后是用boot_map_segment在一级页表的第510项分配了
    一个二级页表，将这个二级页表的前48个页表项分别对应着0x00401000到0x00431000这
    48个页面，而这些页面所对应的虚拟地址中的页面为0x7f800000到7f830000称为PAGES
    的PDMAP，感觉这次实验中的测试函数并没有涉及到这里，因为测试时用的是第一个页面。
    后面的env没有细看，就不说了。
    	建立起虚实映射机制后，开始构建页面机制，首先是page_init，进行已用页面的记录
    引用次数和未用页面加入空闲链表的操作，基于此实现页面的分配和删除操作，此后就
    可以按页来分配内存了。
        以下是我对其中的一些主要函数中的主要操作的理解：
        
        （1）boot_pgdir_walk
        	boot_pgdir_walk的作用是根据虚拟地址找到所对应的二级页表中的页表项的地址，
        如果二级页表不存在并且create标志为1，就新建一个二级页表。
```C
if(!(*pgdir_entryp & PTE_V) && create == 1)
{
   pgtable = alloc(BY2PG, BY2PG, 1);
   *pgdir_entryp = PTE_ADDR(PADDR(pgtable)) | PTE_V;
} 
```
        	新建页表时，首先是调用alloc按字节分配一个页面，地址保存在pgtable里，然后
        取其高20位存入一级页表项的高20位，PADDR是将虚拟地址转为物理地址，PTE_ADDR
        将低12位置0，由于其内存分配是按照页面大小进行对齐的，所以PTE_ADDR用不用都
        一样。从这里也可以看出，一级页表项的高20位存的是二级页表所在的物理地址的高20位。
```C
pgtable = KADDR(PTE_ADDR(*pgdir_entryp));
    pgtable_entry = &pgtable[PTX(va)];
```
        	获取二级目录时，根据一级页表的页表项查询到其所在的页面的物理地址，然后用KADDR
        宏函数转为虚拟地址，最后为了使其变为指针用了强制类型转换。第二步等价于：
```C
pgtable_entry = pgtable + PTX(va) * sizeof(pgtable_entry)
```
        （2） pgdir_walk
        	pgdir_walk的作用与上面所说的boot_pgdir_walk类似，只是此时已经建立起空闲
        链表来管理物理内存，因此在进行空闲内存分配的时候可以直接用page_alloc来实现了。
```C
if(!(*pgdir_entryp & PTE_V)&& create == 1)
{
    if(page_alloc(&ppage) != 0)
        return -E_NO_MEM;
    *pgdir_entryp = page2pa(ppage)| PTE_V;
	ppage->pp_ref =1;
}
```
        	注意到此时分配内存可能会失败，其实上面的boot_pgdir_walk也可能会失败，
        失败直接会引发异常，程序应该会异常终止吧：
```C
panic at pmpa.c:147: out of memory
```
        	我们还发现此处的对页表项的修改与上面的也有不同，因为这里我们得到的
        是二级页表所对应的页面结构的地址，需要根据pages数组的首地址算出偏移
        量来确定其物理地址，这与上面是有所不同的。
        （3） boot_map_segment
			 这个函数我感觉我还没有十分理解，它实现了物理地址和虚拟地址的映射关系
        ，根据我的观察，
```C
pages = (struct Page *)alloc(npage * sizeof(struct Page), BY2PG, 1);
printf("to memory %x for struct Pages.\n", freemem);
n = ROUND(npage * sizeof(struct Page), BY2PG);
boot_map_segment(pgdir, UPAGES, n, PADDR(pages), PTE_R);
```
        	第一次调用的时候，是将刚才才给pages数组分配的空间对应到0x7f800000
        到7fC00000的称为Pages的PDMAP空间，当然由于我们的实际物理内存只有64M
        故而页面数也不多，所以并没有全部占满，只占用了其中的0x7f800000到
        7f830000的空间，所对应的事第511个二级页表，编号为510。
        （4） page_init
        	对于页面的管理是通过维护一个空闲链表来实现的，page_init函数的作用
        就是初始化这个链表，其中包含了将此时的空闲页面加入其中。
```C
LIST_INIT(&page_free_list);
```
        	注意一开始初始化时参数要填地址，我一开始没注意宏函数的定义直接写
        的结构，出了错又回头仔细的看了看queue.h，才明白这里要填的是指针。

```C
if(i<PADDR(freemem)/BY2PG)
    pages[i].pp_ref = 1;
```
        	在判断一个页面是否是已经被使用的时候，上述中的i代表第几个页面，
        PADDR(freemem)得出freemem对应的物理地址，除以BY2PG一个页面的大小
        就可以得出此时用到的最大的页面数了。我觉得下面的方法也是可以的
```C
if(page2pa(&pages[i])  <PADDR( freemem))
    pages[i].pp_ref = 1;
```
        	它是用结构所对应的物理地址来判断内存是否被用过，这里用到的两
        个宏函数的不同与boot_pgdir_walk和pgdir_walk中的不同有些类似，
        一个是直接用虚拟地址直接映射，一个是利用页面结构来间接寻找。
        （5） page_alloc
        	page_alloc的作用是从空闲链表中分配一个页面，注意要判断是否存
        在空闲的页面，
```C
*pp = LIST_FIRST(&page_free_list);
LIST_REMOVE(*pp,pp_link);
bzero((void *)*pp, sizeof(struct Page));
```
        	对于清空这个页面，我以前写的size一直是一个页面的大小，也就是4KB，
        后来测了近一天的时间的BUG，因为在后面的page_check函数里有一个地方
        是对于p1的引用值莫名其妙的从2变为了0，花了近一天的时间才注意到这个
        不令人注意的地方，page_alloc很早就写完了，一直以为没有错，后来才明
        白要写结构的大小。
        	当我重新读了queue.h后发现，当我们释放一个页面时，结构本身的两个指
        针并不会清空，它依旧指着原先链表中的两个节点（若有），我猜测这两个
        指针以后可能会用作判断，故在分配页面的时候要记得清空，但是我也见到
        过清空整个页面的，我觉得既清空结构，又清空页面好像是更加保险吧。
        （6） ROUND
```C
#define ROUND(a, n)    (((((u_long)(a))+(n)-1)) & ~((n)-1))
```
        	ROUND函数的作用是向上按照位数对齐，n为对其的参照，比如n为1K，那么n-1
        如果用二进制表示的话是10个1，取反的话后十位全是0，对于a，如果原先正
        好是1K对齐，那么加上n-1，后十位变为1，取按位与运算后正好把后十位的1
        抹掉，如果原先不是1K对齐，加上n-1后后十位一定会向前进一位，取按位与
        运算后正好把后十位抹掉，而这也正是我们想要的，这个宏函数设计得很巧妙，
        ROUNDDOWN的原理与此类似。
### 三、 实验感想 ###
        这次实验给我感受最深的是那几个头文件，里面的宏函数不仅数量多，而且大多数
    的实现原理还不是显而易见，所以这次实验中的宏函数确实花了很大的功夫。
        相比于上次的Lab1，这次花的时间是几倍的关系，这次的实验是不断地在pmap.c
    和各种宏函数之间穿梭，要填的函数不多，每个的代码量也不多，但却都是短小精悍，
    一条语句常常要包含好几个宏函数，地址之间的转换常常要思考很久，哪里要用虚拟
    地址，哪里要用物理地址，对于一个页表项取的是内容还是其地址，还有二重指针的
    使用和赋值操作等等，多亏了代码中注释的提示，不然要花更多的时间。
        这次的调试也耗费了我很多时间，由于page_alloc函数中清空页面那一条语句我
    给的大小是4KB，一直出不来结果，这都是因为当初对实验内容理解的不够深入，并
    没有十分理解来龙去脉，只是按照定义和注释去凑。
        总体说来，Lab2的难度比Lab1提升了不少，我也大概花了三四天的时间去做，
    其中调试花了一天多，听说Lab3更难且代码量更多了，我最好早早开工吧。
    
        





        
        

