# 操作系统Lab3实验报告 #
## 14061106 朱化磊 ##
### 一、Thinking ###
选做3.1、3.2、3.4、3.5、3.7，3.3和3.6也写了些。
#### Thinking 3.1 
		采用逆序的方式，通过LIST_INSERT_HEAD宏函数，可以将进程按地址（UENV之上的PDMAP空间中env结构的地址）
	从小到大的顺序插入到进程的空闲链表里，这样在使用env_alloc的时候就可以按照这个顺序0,1,2,3...分配进程。
		从网上了解到，Linux中的0号进程是所有进程的祖先，由0号进程去生成1号进程，1号进程去执行内核的部分初
	始化工作及进行系统配置，并创建若干个内核进程，所以0号进程是比较特殊的进程，故我们要保证0号进程要在链表
	的头部。	
		后来经过试验即使不逆序插入，仍然能跑出结果，而且我们所运行的两个进程也就是0和1号进程，这样看来进程
	是几号也不影响运行，所以我就猜测上一段中所涉及的0号进程是不同于数组envs中的，但我注意到在page_alloc函
	数中并没有让页面的分配是按地址从小到大的顺序分配的，可能是页面相比进程来说本来就比较分散，顺序不影响，
	但进程或许按序排列起来会比较好用？
#### Thinking 3.2 ####
	（1）
		这一步操作我们把UTOP之上的页表管理信息都复制到了进程的页表中，根据指导书的解释，这样就相当于用户进
	程拥有了升级为内核态进程的资格，当遇到一些特权指令比如mtc0进程就会陷入内核态，临时转为内核态进程，有了
	这部分信息，转变过程就非常方便了。
	（2）
		UTOP是user top，ULIM是user limit，后者是用户限定的区域分割线，上面2G是内核空间，下面的2G是用户空间，
	前者是用户进程可以使用的数据栈顶，UTOP之下的空间每个用户进程都可以使用，而且这种使用没有其他限制。
		而居于UTOP和ULIM之间的区域是用来保存进程和页表的信息，同时内核进程也会进行访问，和内核进程是有着很
	紧密的联系的，是不能随便修改的，但是其他处于UTOP之下的区域是完全被进程所支配，而且内核也不关心这里的数
	据。
	（3）
		进程的页目录同时也是一个二级目录，这两条语句将页目录映射到VPT和UVPT的位置上。系统一开始所分配的页目
	录（boot_pgdir）的位置就在VPT上，即0x8040000，UVPT即为user VPT，执行完这两条语句后，页目录就作为一个二
	级目录在UVPT的位置上了。
#### Thinking 3.3
		当加载一个进程的二进制镜像的时候，需要告诉函数加载的事哪个进程，use_data就是我们要加载的进程的指针，
	我们把二进制镜像复制到一个一个页面，再一一将这些页面填充到进程的页表项中，这样进程就可以以页面来访问数据
	了，在进程的眼里，这些数据都是从va开始紧密排列好了的。没有这个use_data当然是不行的。
		我没有搞懂这个参数的设计有什么特别之处，就是我们要加载镜像的时候告诉函数是要加载到哪个进程，我觉得这
	就类似于scanf函数，我们要读取一个数据，同时也要告诉函数这个数据保存到哪里以便我们之后的使用。
#### Thinking 3.4
	（1）
		指令地址指的应该是虚拟地址，因为表面上我们是将二进制镜像从va开始拷贝到了内存中，但是实际上二进制镜像
	是拷贝到了一个一个页面，并且这些页面很可能是分散的，进程运行过程中是不关心虚拟地址和物理地址是怎么映射的，
	通过查页表就能够找到真正的指令的地址。
	（2）
		一样的。因为每个进程都是相互独立的进程，它们是互不关心的，都可以讲代码的起始位置设置为同一个值，而这
	里的entry_point记录的是虚拟地址，在真正执行的时候由于进程间页表信息的不同，最终所映射到的物理地址其实是不
	一样的。
	（3）
		我认为程序的入口应该为布局图中的UTEXT的位置上，即为0x400000，但我尝试把entry_point输出来后，发现它的值
	是0x400b0，并不是我想象的那样，之后我从同学那了解到，偏移量的b0是由于ELF文件的标识码所致。
#### Thinking 3.5
		要将当前中断的进程的env_tf.pc设为old.cp0_epc，上学期的计组实验p7中，当发生中断后，根据当前所执行的几条
	指令判断出当返回时所应当执行的指令的地址，并将其保存到cp0中的epc寄存器里，这个地址就是已经处理好了的，返回
	的时候直接将epc赋给pc。这里的原理应该都是一样的，epc保存到了old里的epc，将其赋给curenv.tf里的pc即可。
#### Thinking 3.6
		我认为TIMESTACK以下Trapframe大小的空间是保存了一个由于异常中断而退出的进程的上下文信息的区域，在SAVEALL
	函数中，
```mips
	get_sp      
	move	k1,sp                    
	subu	sp,k1,TF_SIZE  
```
		通过执行get_sp函数将sp设为了TIMESTACK，然后sp减去Trapframe的大小，以此为基址，保存当期进程的上下文。
		而KERNEL_SP的作用我觉得和TIMESTACK有些类似，也是保存进程的上下文的，因为在get_sp函数里，也可能将sp设为
	KERNEL_SP的值，我理解的是造成中断不仅仅有异常中断，还可能有其他原因，而这些其他原因造成的中断处理中，可能就
	会将进程的上下文保存到KERNEL_SP之下了。
#### Thinking 3.7
	（1）
		我写的调度方法是每次都从计数器开始遍历envs数组，直到找到装态为RUNNABLE的进程，然后启动它。
		然而这种时间片轮转的方法存在的不公在于，调度方法的时间也是在时间片内的，若每次运行调度方法所用的时间不一
	样，那么很明显实际上分配给每个进程的时间其实是不一样的，就我们这次实验来说，两个进程分别保存到envs[0]和envs[1]，
	分别记为进程A和进程B，第一次调度的时候，一下子就找到了进程A，直接运行，当再次调度时，同样也是一下子就找到了进程
	B，而当再次调度时，计数器要一直遍历到NENV，然后才能找到进程A，以后每一轮的调度都是这样，找到进程A所花的时间要远
	远高于找到进程B，造成分配给A的时间实际上要小于B的，从输出上可以看出，2的数量要高于1几倍的。
		（2）
		就这次的实验来说，既然已知只有两个进程，那么计数器可以只检查envs[0]和envs[1]，可以降低由于调度方法耗费时间
	不一致带来的不公平。	
### 二、实验难点图示
	![env-start](https://github.com/HualeiZhu/BUAA_MIPS_OS_DOC/blob/master/lab3-env-start.jpg)
	
	

	
