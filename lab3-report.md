# 操作系统Lab3实验报告 #
## 14061106 朱化磊 ##
### 一、Thinking ###
选做3.1、3.2、3.4、3.5、3.7，3.3和3.6也写了些。
#### Thinking 3.1 
		采用逆序的方式，通过LIST_INSERT_HEAD宏函数，可以将进程按地址（UENV之上的PDMAP空间中env结构的地址）
	从小到大的顺序插入到进程的空闲链表里，这样在使用env_alloc的时候就可以按照这个顺序0,1,2,3...分配进程。
		从网上了解到，Linux中的0号进程是所有进程的祖先，由0号进程去生成1号进程，1号进程去执行内核的部分初
	始化工作及进行系统配置，并创建若干个内核进程，所以0号进程是比较特殊的进程，故我们要保证0号进程要在链表
	的头部。	
		后来经过试验即使不逆序插入，仍然能跑出结果，而且我们所运行的两个进程也就是0和1号进程，这样看来进程
	是几号也不影响运行，所以我就猜测上一段中所涉及的0号进程是不同于数组envs中的，但我注意到在page_alloc函
	数中并没有让页面的分配是按地址从小到大的顺序分配的，可能是页面相比进程来说本来就比较分散，顺序不影响，
	但进程或许按序排列起来会比较好用？
#### Thinking 3.2 ####
	（1）
		这一步操作我们把UTOP之上的页表管理信息都复制到了进程的页表中，根据指导书的解释，这样就相当于用户进
	程拥有了升级为内核态进程的资格，当遇到一些特权指令比如mtc0进程就会陷入内核态，临时转为内核态进程，有了
	这部分信息，转变过程就非常方便了。
	（2）
		UTOP是user top，ULIM是user limit，后者是用户限定的区域分割线，上面2G是内核空间，下面的2G是用户空间，
	前者是用户进程可以使用的数据栈顶，UTOP之下的空间每个用户进程都可以使用，而且这种使用没有其他限制。
		而居于UTOP和ULIM之间的区域是用来保存进程和页表的信息，同时内核进程也会进行访问，和内核进程是有着很
	紧密的联系的，是不能随便修改的，但是其他处于UTOP之下的区域是完全被进程所支配，而且内核也不关心这里的数
	据。
	（3）
		进程的页目录同时也是一个二级目录，这两条语句将页目录映射到VPT和UVPT的位置上。系统一开始所分配的页目
	录（boot_pgdir）的位置就在VPT上，即0x8040000，UVPT即为user VPT，执行完这两条语句后，页目录就作为一个二
	级目录在UVPT的位置上了。
#### Thinking 3.3
		当加载一个进程的二进制镜像的时候，需要告诉函数加载的事哪个进程，use_data就是我们要加载的进程的指针，
	我们把二进制镜像复制到一个一个页面，再一一将这些页面填充到进程的页表项中，这样进程就可以以页面来访问数据
	了，在进程的眼里，这些数据都是从va开始紧密排列好了的。没有这个use_data当然是不行的。
		我没有搞懂这个参数的设计有什么特别之处，就是我们要加载镜像的时候告诉函数是要加载到哪个进程，我觉得这
	就类似于scanf函数，我们要读取一个数据，同时也要告诉函数这个数据保存到哪里以便我们之后的使用。
#### Thinking 3.4
	（1）
		指令地址指的应该是虚拟地址，因为表面上我们是将二进制镜像从va开始拷贝到了内存中，但是实际上二进制镜像
	是拷贝到了一个一个页面，并且这些页面很可能是分散的，进程运行过程中是不关心虚拟地址和物理地址是怎么映射的，
	通过查页表就能够找到真正的指令的地址。
	（2）
		一样的。因为每个进程都是相互独立的进程，它们是互不关心的，都可以讲代码的起始位置设置为同一个值，而这
	里的entry_point记录的是虚拟地址，在真正执行的时候由于进程间页表信息的不同，最终所映射到的物理地址其实是不
	一样的。
	（3）
		我认为程序的入口应该为布局图中的UTEXT的位置上，即为0x400000，但我尝试把entry_point输出来后，发现它的值
	是0x400b0，并不是我想象的那样，之后我从同学那了解到，偏移量的b0是由于ELF文件的标识码所致。
#### Thinking 3.5
		要将当前中断的进程的env_tf.pc设为old.cp0_epc，上学期的计组实验p7中，当发生中断后，根据当前所执行的几条
	指令判断出当返回时所应当执行的指令的地址，并将其保存到cp0中的epc寄存器里，这个地址就是已经处理好了的，返回
	的时候直接将epc赋给pc。这里的原理应该都是一样的，epc保存到了old里的epc，将其赋给curenv.tf里的pc即可。
#### Thinking 3.6
		我认为TIMESTACK以下Trapframe大小的空间是保存了一个由于异常中断而退出的进程的上下文信息的区域，在SAVEALL
	函数中，
```mips
	get_sp      
	move	k1,sp                    
	subu	sp,k1,TF_SIZE  
```
		通过执行get_sp函数将sp设为了TIMESTACK，然后sp减去Trapframe的大小，以此为基址，保存当期进程的上下文。
		而KERNEL_SP的作用我觉得和TIMESTACK有些类似，也是保存进程的上下文的，因为在get_sp函数里，也可能将sp设为
	KERNEL_SP的值，我理解的是造成中断不仅仅有异常中断，还可能有其他原因，而这些其他原因造成的中断处理中，可能就
	会将进程的上下文保存到KERNEL_SP之下了。
#### Thinking 3.7
	（1）
		我写的调度方法是每次都从计数器开始遍历envs数组，直到找到装态为RUNNABLE的进程，然后启动它。
		然而这种时间片轮转的方法存在的不公在于，调度方法的时间也是在时间片内的，若每次运行调度方法所用的时间不一
	样，那么很明显实际上分配给每个进程的时间其实是不一样的，就我们这次实验来说，两个进程分别保存到envs[0]和envs[1]，
	分别记为进程A和进程B，第一次调度的时候，一下子就找到了进程A，直接运行，当再次调度时，同样也是一下子就找到了进程
	B，而当再次调度时，计数器要一直遍历到NENV，然后才能找到进程A，以后每一轮的调度都是这样，找到进程A所花的时间要远
	远高于找到进程B，造成分配给A的时间实际上要小于B的，从输出上可以看出，2的数量要高于1几倍的。
	（2）
		就这次的实验来说，既然已知只有两个进程，那么计数器可以只检查envs[0]和envs[1]，可以降低由于调度方法耗费时间
	不一致带来的不公平。	
### 二、实验难点图示
	下图为一个进程从创建到运行的简单过程
	![env-start](https://raw.githubusercontent.com/HualeiZhu/BUAA_MIPS_OS_DOC/master/lab3-env-start.png)
	下面我分析一下进程的切换过程，看得也不太明白，只能尽力说了。
	(1)
		发生时钟中断之后，会引发MIPS中断，从而将PC指向0x80000080，主要执行
```mips
	mfc0 k1,CP0_CAUSE
	la k0,exception_handlers
	andi k1,0x7c
	addu k0,k1
	lw k0,(k0)
	NOP
	jr k0
```
		exception_handlers是中断处理函数的数组，根据CP0_CAUSE中异常中断位判断是哪一个中断，并跳到应当的中断处理函
	数。
	（2）
		在中断处理函数handle_int中，主要执行了三部分内容：
		1、SAVEALL：
			在SAVEALL函数中，会首先调用get_sp来重设sp的值，我们实验中会将sp设为0x82000000，即为TIMESTACK的值，然后
		将当前的上下文保存到TIMESTACK以下的区域内。
		2、CLI：
			将CP0_STATUS的第0位设为0，屏蔽中断，将28位设为1，表示处于用户模式下。
		3、
			判断CP0_STATUS和CP0_CAUSE的第十二位是否同时为1，表示是否可以响应4号中断，在我们的实验中是可以的，然后跳
		到我们的调度函数。
	（3）
		当调度完毕，进入到env_run函数中，首先保存当前进程的上下文，我们知道此时进程的上下文已经保存到了TIMESTACk下
	的区域了，所以要将这部分的内容拷贝到当前进程中的env_tf结构中，并重新设pc值。
	（4）
		保存完上下文后，我们要做的是启动这个新的进程。首先将记录当前进程的变量设为要执行的进程，然后切换地址空间，
	那什么叫做切换空间呢？以下是我的理解。
		我们看到，每一个进程都有一个页目录，在lab2中也知道在mips_vm_init函数中分配了一个页目录，这个页目录，我认为
	就代表了一种空间的概念。程序中的mCONTEXT一开始是0x80400000，当执行lcontext时，将要执行的进程的页目录的地址保存
	到mCONTEXT的位置上，我感觉就是将系统的页目录的第一个页表项改为进程页目录的地址。最后恢复进程上下文，env_pop_tf
	将进程的env_tf结构中保存的值拷贝到当前的上下文，以实现上下文的切换，最后直接跳到进程保存的pc值，实现进程的切换。
### 三、实验感想 
		这次的实验确实有几个坑函数的，load_icode_mapper是我认为最坑的了，一开始怎么加载镜像我都卡了好久，因为一直没
	想到用page_insert函数，总觉得分配了页面但是没用到（我在bcopy里直接用的是bin和va），后来想到了page_insert才看到
	了曙光，好歹写完后又被没对齐的va坑了一次，在同学的帮助下才慢慢跑出了结果。
		感觉这次的lab3比lab2又难了不少，不仅仅是函数多，这次有一些函数是要看汇编代码才能写的，比如lcontext函数，我是
	从mCONTEXT入手，类比0x80400000的含义，猜出要填进程页目录的虚拟地址，还有整个的中断过程，我也知道我看出来的也不一
	定对，但从汇编代码可以更加清晰地展示出整个的运行过程。我从这次的实验也体会到，单单凭注释和指导书越来越难写出代码
	了，需要自己思考的东西变多了，需要花费的时间也增多了，这次的实验花了大约3、4天的样子，希望下次实验可以顺利一些，
	可以减少一个小细节耗费很多时间的情况。
	
	

	
